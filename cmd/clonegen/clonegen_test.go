package main

import (
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
)

func TestCloneGenBasic(t *testing.T) {
	// Create temp directory
	tmpDir, err := os.MkdirTemp("", "clonegen-test-*")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tmpDir)

	// Write go.mod
	goMod := "module testpkg\n\ngo 1.21\n"
	if err := os.WriteFile(filepath.Join(tmpDir, "go.mod"), []byte(goMod), 0644); err != nil {
		t.Fatal(err)
	}

	// Write test source file
	testSrc := `package testpkg

type Simple struct {
	Name   string
	Value  int
	Score  float64
	Active bool
}

type WithSlice struct {
	Items []string
	Nums  []int
}

type WithMap struct {
	Data map[string]int
	Tags map[int]string
}

type WithPointer struct {
	Ptr    *string
	NumPtr *int
}

type Nested struct {
	Simple Simple
	Items  []Simple
}

type WithAll struct {
	Name     string
	Values   []int
	Mapping  map[string]string
	Ptr      *int
	Nested   Simple
	SlicePtr []*Simple
}
`
	srcPath := filepath.Join(tmpDir, "types.go")
	if err := os.WriteFile(srcPath, []byte(testSrc), 0644); err != nil {
		t.Fatal(err)
	}

	// Change to temp directory and run generator
	oldDir, _ := os.Getwd()
	os.Chdir(tmpDir)
	defer os.Chdir(oldDir)

	// Test parsing
	pkg, err := parsePackage(".")
	if err != nil {
		t.Fatalf("parsePackage: %v", err)
	}

	if pkg.Name != "testpkg" {
		t.Errorf("expected package name 'testpkg', got '%s'", pkg.Name)
	}

	expectedTypes := []string{"Simple", "WithSlice", "WithMap", "WithPointer", "Nested", "WithAll"}
	for _, name := range expectedTypes {
		if _, ok := pkg.Structs[name]; !ok {
			t.Errorf("expected struct %s not found", name)
		}
	}
}

func TestAnalyzer(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "clonegen-test-*")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tmpDir)

	// Write go.mod
	goMod := "module testpkg\n\ngo 1.21\n"
	if err := os.WriteFile(filepath.Join(tmpDir, "go.mod"), []byte(goMod), 0644); err != nil {
		t.Fatal(err)
	}

	testSrc := `package testpkg

type Item struct {
	ID   string
	Name string
}

func (i Item) Clone() Item {
	return Item{ID: i.ID, Name: i.Name}
}

type Container struct {
	Items    []Item
	ItemMap  map[string]Item
	ItemPtr  *Item
	Strings  []string
	Numbers  map[int]float64
	Data     any
}
`
	srcPath := filepath.Join(tmpDir, "types.go")
	if err := os.WriteFile(srcPath, []byte(testSrc), 0644); err != nil {
		t.Fatal(err)
	}

	oldDir, _ := os.Getwd()
	os.Chdir(tmpDir)
	defer os.Chdir(oldDir)

	pkg, err := parsePackage(".")
	if err != nil {
		t.Fatalf("parsePackage: %v", err)
	}

	analyzer := NewAnalyzer(pkg, "Clone")

	info, err := analyzer.Analyze("Container")
	if err != nil {
		t.Fatalf("Analyze: %v", err)
	}

	if info.Name != "Container" {
		t.Errorf("expected type name 'Container', got '%s'", info.Name)
	}

	if len(info.Fields) != 6 {
		t.Errorf("expected 6 fields, got %d", len(info.Fields))
	}

	// Check field kinds
	fieldKinds := map[string]FieldKind{
		"Items":   KindSlice,
		"ItemMap": KindMap,
		"ItemPtr": KindPointer,
		"Strings": KindSlice,
		"Numbers": KindMap,
		"Data":    KindInterface,
	}

	for _, f := range info.Fields {
		expected, ok := fieldKinds[f.Name]
		if !ok {
			continue
		}
		if f.Kind != expected {
			t.Errorf("field %s: expected kind %v, got %v", f.Name, expected, f.Kind)
		}
	}
}

func TestGenerator(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "clonegen-test-*")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tmpDir)

	// Write go.mod
	goMod := "module testpkg\n\ngo 1.21\n"
	if err := os.WriteFile(filepath.Join(tmpDir, "go.mod"), []byte(goMod), 0644); err != nil {
		t.Fatal(err)
	}

	testSrc := `package testpkg

type Item struct {
	ID    string
	Value int
}

type Game struct {
	Name    string
	Score   int
	Items   []Item
	Scores  map[string]int
	Config  *Item
}
`
	srcPath := filepath.Join(tmpDir, "types.go")
	if err := os.WriteFile(srcPath, []byte(testSrc), 0644); err != nil {
		t.Fatal(err)
	}

	oldDir, _ := os.Getwd()
	os.Chdir(tmpDir)
	defer os.Chdir(oldDir)

	pkg, err := parsePackage(".")
	if err != nil {
		t.Fatalf("parsePackage: %v", err)
	}

	analyzer := NewAnalyzer(pkg, "Clone")

	itemInfo, err := analyzer.Analyze("Item")
	if err != nil {
		t.Fatalf("Analyze Item: %v", err)
	}

	gameInfo, err := analyzer.Analyze("Game")
	if err != nil {
		t.Fatalf("Analyze Game: %v", err)
	}

	gen := NewGenerator("testpkg", false, nil, nil)
	code, err := gen.Generate([]*TypeInfo{itemInfo, gameInfo})
	if err != nil {
		t.Fatalf("Generate: %v", err)
	}

	codeStr := string(code)

	// Check for expected content
	expectedParts := []string{
		"// Code generated by clonegen. DO NOT EDIT.",
		"package testpkg",
		"func (src Item) Clone() Item",
		"func (src Game) Clone() Game",
		"dst.Items = make([]Item, len(src.Items))",
		"dst.Scores = make(map[string]int, len(src.Scores))",
		"if src.Config != nil",
	}

	for _, part := range expectedParts {
		if !strings.Contains(codeStr, part) {
			t.Errorf("expected generated code to contain: %s", part)
		}
	}
}

func TestFullGeneration(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "clonegen-fulltest-*")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tmpDir)

	// Write test file
	testSrc := `package main

type Player struct {
	ID    string
	Name  string
	Score int
	Hand  []int
}

type Game struct {
	Round   int
	Phase   string
	Players []Player
	Scores  map[string]int
}
`
	srcPath := filepath.Join(tmpDir, "game.go")
	if err := os.WriteFile(srcPath, []byte(testSrc), 0644); err != nil {
		t.Fatal(err)
	}

	// Write go.mod
	goMod := `module testmod

go 1.21
`
	modPath := filepath.Join(tmpDir, "go.mod")
	if err := os.WriteFile(modPath, []byte(goMod), 0644); err != nil {
		t.Fatal(err)
	}

	oldDir, _ := os.Getwd()
	os.Chdir(tmpDir)
	defer os.Chdir(oldDir)

	// Run the generator
	cfg := Config{
		Types:   []string{"Player", "Game"},
		Output:  "clone_gen.go",
		Verbose: false,
	}

	if err := run(cfg); err != nil {
		t.Fatalf("run: %v", err)
	}

	// Check generated file exists
	genPath := filepath.Join(tmpDir, "clone_gen.go")
	content, err := os.ReadFile(genPath)
	if err != nil {
		t.Fatalf("read generated file: %v", err)
	}

	// Write test file that uses generated clones
	testFile := `package main

import (
	"reflect"
	"testing"
)

func TestPlayerClone(t *testing.T) {
	p := Player{
		ID:    "p1",
		Name:  "Alice",
		Score: 100,
		Hand:  []int{1, 2, 3},
	}

	clone := p.Clone()

	// Check equality
	if !reflect.DeepEqual(p, clone) {
		t.Error("clone should equal original")
	}

	// Check isolation
	clone.Hand[0] = 999
	if p.Hand[0] == 999 {
		t.Error("modifying clone should not affect original")
	}
}

func TestGameClone(t *testing.T) {
	g := Game{
		Round: 1,
		Phase: "playing",
		Players: []Player{
			{ID: "p1", Name: "Alice", Hand: []int{1, 2}},
			{ID: "p2", Name: "Bob", Hand: []int{3, 4}},
		},
		Scores: map[string]int{"p1": 100, "p2": 200},
	}

	clone := g.Clone()

	// Check equality
	if !reflect.DeepEqual(g, clone) {
		t.Error("clone should equal original")
	}

	// Check isolation - modify slice
	clone.Players[0].Name = "Modified"
	if g.Players[0].Name == "Modified" {
		t.Error("modifying clone player should not affect original")
	}

	// Check isolation - modify map
	clone.Scores["p1"] = 999
	if g.Scores["p1"] == 999 {
		t.Error("modifying clone scores should not affect original")
	}
}
`
	testPath := filepath.Join(tmpDir, "clone_test.go")
	if err := os.WriteFile(testPath, []byte(testFile), 0644); err != nil {
		t.Fatalf("write test file: %v", err)
	}

	// Run go test
	cmd := exec.Command("go", "test", "-v")
	cmd.Dir = tmpDir
	output, err := cmd.CombinedOutput()
	if err != nil {
		t.Fatalf("go test failed: %v\nOutput:\n%s\nGenerated code:\n%s", err, output, content)
	}

	t.Logf("Generated code:\n%s", content)
	t.Logf("Test output:\n%s", output)
}

func TestEdgeCases(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "clonegen-edge-*")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tmpDir)

	testSrc := `package testpkg

import "time"

type EdgeCases struct {
	// Primitives
	Int     int
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint    uint
	Uint8   uint8
	Float32 float32
	Float64 float64
	Bool    bool
	String  string
	Byte    byte
	Rune    rune

	// Time
	Time     time.Time
	Duration time.Duration

	// Interfaces
	Any   any
	Error error

	// Nested slices
	Matrix [][]int

	// Nested maps
	NestedMap map[string]map[string]int

	// Array
	FixedArr [3]int
}
`
	srcPath := filepath.Join(tmpDir, "types.go")
	if err := os.WriteFile(srcPath, []byte(testSrc), 0644); err != nil {
		t.Fatal(err)
	}

	goMod := `module testpkg

go 1.21
`
	modPath := filepath.Join(tmpDir, "go.mod")
	if err := os.WriteFile(modPath, []byte(goMod), 0644); err != nil {
		t.Fatal(err)
	}

	oldDir, _ := os.Getwd()
	os.Chdir(tmpDir)
	defer os.Chdir(oldDir)

	cfg := Config{
		Types:   []string{"EdgeCases"},
		Output:  "clone_gen.go",
		Verbose: true,
	}

	if err := run(cfg); err != nil {
		t.Fatalf("run: %v", err)
	}

	content, err := os.ReadFile(filepath.Join(tmpDir, "clone_gen.go"))
	if err != nil {
		t.Fatalf("read generated file: %v", err)
	}

	t.Logf("Generated code for edge cases:\n%s", content)

	// Verify it compiles
	cmd := exec.Command("go", "build", ".")
	cmd.Dir = tmpDir
	output, err := cmd.CombinedOutput()
	if err != nil {
		t.Fatalf("go build failed: %v\nOutput:\n%s", err, output)
	}
}
