package main

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"
	"text/template"
)

// Generator generates Clone() method code
type Generator struct {
	packageName     string
	pointerReceiver bool
	skipFields      map[string]bool
	imports         map[string]bool
	warnings        []string
}

// NewGenerator creates a new code generator
func NewGenerator(packageName string, pointerReceiver bool, skipFields []string) *Generator {
	skip := make(map[string]bool)
	for _, f := range skipFields {
		skip[f] = true
	}
	return &Generator{
		packageName:     packageName,
		pointerReceiver: pointerReceiver,
		skipFields:      skip,
		imports:         make(map[string]bool),
	}
}

// Generate generates code for all types
func (g *Generator) Generate(types []*TypeInfo) ([]byte, error) {
	var methods []string

	for _, t := range types {
		method, err := g.generateCloneMethod(t)
		if err != nil {
			return nil, fmt.Errorf("generate %s: %w", t.Name, err)
		}
		methods = append(methods, method)
	}

	// Build imports
	var importLines []string
	for imp := range g.imports {
		importLines = append(importLines, fmt.Sprintf("\t%q", imp))
	}

	// Generate final file
	var buf bytes.Buffer
	buf.WriteString("// Code generated by clonegen. DO NOT EDIT.\n")
	buf.WriteString("//go:build !clonegen_ignore\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", g.packageName))

	if len(importLines) > 0 {
		buf.WriteString("import (\n")
		for _, imp := range importLines {
			buf.WriteString(imp + "\n")
		}
		buf.WriteString(")\n\n")
	}

	// Add warnings as comments
	if len(g.warnings) > 0 {
		buf.WriteString("// Generation warnings:\n")
		for _, w := range g.warnings {
			buf.WriteString(fmt.Sprintf("//   - %s\n", w))
		}
		buf.WriteString("\n")
	}

	for _, method := range methods {
		buf.WriteString(method)
		buf.WriteString("\n")
	}

	// Format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted if formatting fails (helps debugging)
		return buf.Bytes(), nil
	}

	return formatted, nil
}

// generateCloneMethod generates Clone() for a single type
func (g *Generator) generateCloneMethod(t *TypeInfo) (string, error) {
	var buf bytes.Buffer

	receiver := "src"
	receiverType := t.Name
	if g.pointerReceiver {
		receiverType = "*" + t.Name
	}

	buf.WriteString(fmt.Sprintf("// Clone creates a deep copy of %s\n", t.Name))
	buf.WriteString(fmt.Sprintf("func (%s %s) Clone() %s {\n", receiver, receiverType, t.Name))

	// Collect primitive assignments and complex fields
	var primitiveAssigns []string
	var complexFields []*FieldInfo

	for _, field := range t.Fields {
		if g.skipFields[field.Name] {
			continue
		}

		if !field.IsExported && !field.Embedded {
			g.warnings = append(g.warnings, fmt.Sprintf("%s.%s: unexported field - skipped", t.Name, field.Name))
			continue
		}

		if field.Warning != "" {
			g.warnings = append(g.warnings, fmt.Sprintf("%s.%s: %s", t.Name, field.Name, field.Warning))
		}

		switch field.Kind {
		case KindPrimitive, KindString, KindTime, KindInterface, KindChan, KindFunc:
			primitiveAssigns = append(primitiveAssigns, field.Name)
		default:
			complexFields = append(complexFields, field)
		}
	}

	// Generate dst initialization with primitive fields
	buf.WriteString(fmt.Sprintf("\tdst := %s{\n", t.Name))
	for _, name := range primitiveAssigns {
		buf.WriteString(fmt.Sprintf("\t\t%s: %s.%s,\n", name, receiver, name))
	}
	buf.WriteString("\t}\n")

	// Generate complex field cloning
	for _, field := range complexFields {
		code := g.generateFieldClone(field, receiver)
		buf.WriteString("\n")
		buf.WriteString(code)
	}

	buf.WriteString("\n\treturn dst\n")
	buf.WriteString("}\n")

	return buf.String(), nil
}

// generateFieldClone generates cloning code for a complex field
func (g *Generator) generateFieldClone(field *FieldInfo, receiver string) string {
	var buf bytes.Buffer
	src := fmt.Sprintf("%s.%s", receiver, field.Name)
	dst := fmt.Sprintf("dst.%s", field.Name)

	switch field.Kind {
	case KindSlice:
		buf.WriteString(g.generateSliceClone(field, src, dst))

	case KindArray:
		buf.WriteString(g.generateArrayClone(field, src, dst))

	case KindMap:
		buf.WriteString(g.generateMapClone(field, src, dst))

	case KindPointer:
		buf.WriteString(g.generatePointerClone(field, src, dst))

	case KindStruct:
		if field.Embedded {
			if field.HasClone {
				buf.WriteString(fmt.Sprintf("\t%s = %s.Clone()\n", dst, src))
			} else {
				buf.WriteString(fmt.Sprintf("\t%s = %s // embedded struct - shallow copy\n", dst, src))
			}
		} else {
			if field.HasClone {
				buf.WriteString(fmt.Sprintf("\t%s = %s.Clone()\n", dst, src))
			} else {
				buf.WriteString(fmt.Sprintf("\t%s = %s // struct without Clone - shallow copy\n", dst, src))
			}
		}

	default:
		// Shallow copy for unknown/interface/chan/func
		buf.WriteString(fmt.Sprintf("\t%s = %s // %s\n", dst, src, field.Kind))
	}

	return buf.String()
}

// generateSliceClone generates slice cloning code
func (g *Generator) generateSliceClone(field *FieldInfo, src, dst string) string {
	var buf bytes.Buffer

	buf.WriteString(fmt.Sprintf("\tif %s != nil {\n", src))
	buf.WriteString(fmt.Sprintf("\t\t%s = make(%s, len(%s))\n", dst, field.TypeStr, src))

	elemClone := g.getElemCloneExpr(field, "v")

	if elemClone == "v" {
		// Simple copy for primitives
		buf.WriteString(fmt.Sprintf("\t\tcopy(%s, %s)\n", dst, src))
	} else {
		buf.WriteString(fmt.Sprintf("\t\tfor i, v := range %s {\n", src))
		buf.WriteString(fmt.Sprintf("\t\t\t%s[i] = %s\n", dst, elemClone))
		buf.WriteString("\t\t}\n")
	}

	buf.WriteString("\t}\n")
	return buf.String()
}

// generateArrayClone generates array cloning code
func (g *Generator) generateArrayClone(field *FieldInfo, src, dst string) string {
	var buf bytes.Buffer

	elemClone := g.getElemCloneExpr(field, "v")

	if elemClone == "v" {
		// Simple assignment for arrays of primitives
		buf.WriteString(fmt.Sprintf("\t%s = %s\n", dst, src))
	} else {
		buf.WriteString(fmt.Sprintf("\tfor i, v := range %s {\n", src))
		buf.WriteString(fmt.Sprintf("\t\t%s[i] = %s\n", dst, elemClone))
		buf.WriteString("\t}\n")
	}

	return buf.String()
}

// generateMapClone generates map cloning code
func (g *Generator) generateMapClone(field *FieldInfo, src, dst string) string {
	var buf bytes.Buffer

	buf.WriteString(fmt.Sprintf("\tif %s != nil {\n", src))
	buf.WriteString(fmt.Sprintf("\t\t%s = make(%s, len(%s))\n", dst, field.TypeStr, src))

	elemClone := g.getMapValueCloneExpr(field, "v")

	buf.WriteString(fmt.Sprintf("\t\tfor k, v := range %s {\n", src))
	buf.WriteString(fmt.Sprintf("\t\t\t%s[k] = %s\n", dst, elemClone))
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t}\n")

	return buf.String()
}

// generatePointerClone generates pointer cloning code
func (g *Generator) generatePointerClone(field *FieldInfo, src, dst string) string {
	var buf bytes.Buffer

	buf.WriteString(fmt.Sprintf("\tif %s != nil {\n", src))

	switch field.ElemKind {
	case KindPrimitive, KindString:
		buf.WriteString(fmt.Sprintf("\t\tv := *%s\n", src))
		buf.WriteString(fmt.Sprintf("\t\t%s = &v\n", dst))

	case KindStruct:
		if field.HasClone {
			buf.WriteString(fmt.Sprintf("\t\tv := %s.Clone()\n", src))
			buf.WriteString(fmt.Sprintf("\t\t%s = &v\n", dst))
		} else {
			buf.WriteString(fmt.Sprintf("\t\tv := *%s // struct without Clone - shallow copy\n", src))
			buf.WriteString(fmt.Sprintf("\t\t%s = &v\n", dst))
		}

	case KindSlice:
		// Pointer to slice
		buf.WriteString(fmt.Sprintf("\t\tsliceCopy := make(%s, len(*%s))\n", field.ElemType, src))
		buf.WriteString(fmt.Sprintf("\t\tcopy(sliceCopy, *%s)\n", src))
		buf.WriteString(fmt.Sprintf("\t\t%s = &sliceCopy\n", dst))

	case KindMap:
		// Pointer to map - need to clone the map
		buf.WriteString(fmt.Sprintf("\t\tmapCopy := make(%s, len(*%s))\n", field.ElemType, src))
		buf.WriteString(fmt.Sprintf("\t\tfor k, v := range *%s {\n", src))
		buf.WriteString("\t\t\tmapCopy[k] = v\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString(fmt.Sprintf("\t\t%s = &mapCopy\n", dst))

	default:
		buf.WriteString(fmt.Sprintf("\t\tv := *%s\n", src))
		buf.WriteString(fmt.Sprintf("\t\t%s = &v\n", dst))
	}

	buf.WriteString("\t}\n")
	return buf.String()
}

// getElemCloneExpr returns the expression to clone a slice/array element
func (g *Generator) getElemCloneExpr(field *FieldInfo, varName string) string {
	switch field.ElemKind {
	case KindPrimitive, KindString, KindTime, KindInterface:
		return varName

	case KindStruct:
		if field.HasClone {
			return varName + ".Clone()"
		}
		return varName

	case KindPointer:
		// Pointer element in slice, e.g., []*Item
		if field.HasClone {
			return fmt.Sprintf("func() %s { if %s == nil { return nil }; v := %s.Clone(); return &v }()",
				field.ElemType, varName, varName)
		}
		return fmt.Sprintf("func() %s { if %s == nil { return nil }; v := *%s; return &v }()",
			field.ElemType, varName, varName)

	case KindSlice:
		// Nested slice
		return fmt.Sprintf("append(%s(nil), %s...)", field.ElemType, varName)

	case KindMap:
		// Map in slice - simplified shallow copy
		return varName

	default:
		return varName
	}
}

// getMapValueCloneExpr returns the expression to clone a map value
func (g *Generator) getMapValueCloneExpr(field *FieldInfo, varName string) string {
	switch field.ElemKind {
	case KindPrimitive, KindString, KindTime, KindInterface:
		return varName

	case KindStruct:
		if field.HasClone {
			return varName + ".Clone()"
		}
		return varName

	case KindPointer:
		if field.HasClone {
			return fmt.Sprintf("func() %s { if %s == nil { return nil }; v := %s.Clone(); return &v }()",
				field.ElemType, varName, varName)
		}
		return fmt.Sprintf("func() %s { if %s == nil { return nil }; v := *%s; return &v }()",
			field.ElemType, varName, varName)

	case KindSlice:
		return fmt.Sprintf("append(%s(nil), %s...)", field.ElemType, varName)

	default:
		return varName
	}
}

// Unused but kept for potential template-based generation
var _ = template.FuncMap{
	"lower": strings.ToLower,
}
